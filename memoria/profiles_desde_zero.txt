1.- Preparacion de la máquina virtual
1.1.- Preparar la maquina con Android SDK

Se ha elegido el sdk r24.0.2-linux.tgz para poder conocer completamente el uso de las herramientas del sdk y avd y como se lanzan los modulos desde la consola de comandos, aunque si bien es cierto que el android studio es más amigable, trabajando desde la consola podemos conocer mas afondo las distintas partes del sdk, donde encontrarlas y para que sirven.

Lo primero que haremos será descomprimir en android SDK manager r24.0.2-linux.tgz y copiarlo como android-sdk en la carpeta de usuario.

Para comenzar trabajar con el sdk necesita algun jdk para ello, no nos importa de momento cual instalemos.

sudo apt-get install default-jdk

Ahora lanzamos el android SDK manager que esta en la carpeta con

~/android-sdk/tools/android

Seleccionamos tal como se muestra:

-Android SDK Tools
-Android SDK Platform-tools
-Android SDK Build-tools
-Android 4.1.2 (API 16)
  -SDK Platform
  -ARM EABI v7a System Image

Volvemos a lanzar:

~/android-sdk/tools/android

Y ahora seleccionamos las ultimas versiones que se nos ofrezcan que mostramos, esto depurará errores en la ejecución de la maquinas virtuales

-Android SDK Tools
-Android SDK Platform-tools
-Android SDK Build-tools

Antes de continuar vamos a agregar el SDK al PATH del sistema que podemos hacer persistente si lo agregamos en el fichero .bashrc para que no tengamos que agregarlo cada vez que abramos una terminal.

export PATH=$PATH:~/android-sdk/tools:~/android-sdk/build-tools/29.0.2/:~/android-sdk/platform-tools

Según aparece en la documentación de Android que se puede consultar aquí:

https://source.android.com/setup/build/initializing

para inicializar un entorno de construcción son necesarias las siguientes dependencias para ubuntu 14.04 64 bits.

sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev libxml2-utils xsltproc unzip mesa-utils lib64stdc++6:i386

he probado varias distribuiones de linux y realmente la que mejor se adecua y menos problemas da para crear máquinas virtuales con el avd manager y las posteriores operaciones de compilacion de kernel, LiME y la creación de profiles para volatility es la 14.04 tal y como se recomienda en el enlace anterior.

Si comprobamos la dependencias que recomiendan desde Android Source podemos comprobar que hemos añadido dos más, que las dos últimas de esa forma no tendremos problemas cuando estemos "construyendo".

Además algo que no nos mencionan en el Android Source y que nos ha ocasionado molestias a la hora de crear los ficheros correspondientes a las imágenes de sistema de las máquinas virtuales de avd, concretamente al generar el fichero que emularará la imagen de la /sdcard es por falta de permisos de ejecución en algunos de esos modulos, en este caso en el mksdcard. Si esto sucediera hay que darle permisos a la carpeta ~/android-sdk/tools podemos hacerlo con:

sudo chmod +x -R ~/android-sdk/tools

Una vez aclarado ese aspecto vamos a hacer uso el Android Virtual Device (AVD) Manager para crear nuestro dispositivo virtual o máquina virtual que usa cuckoodroid en el modo AVD, android 4.1.2 arm, y que la vamos a configurar de la forma que a continuación se expone. Notese que el tamaño de la tarjeta de memoria (sdcard) es de 800mb para que el volcado de emmoria de 512mb quepa sin problemas en la sdcard cuando lancemos LiME para obtener un volcado de memoria.

[imagen crear_mv_avd]

Como se puede apreciar en la imagen la configuración realizada es la que aparece en el wiki de cuckoodroid en el apartado de preparacion del invitado en modo Android emulator

https://cuckoo-droid.readthedocs.io/en/latest/installation/guest_android_avd/requirements/#create-android-virtual-device

y que tan sólo hemos cambiado he cambiado el tamaño de la sdcard a 800mb con la justificación aportada anteriormente.

Para parámetro SKIN vamos a seleccionar "Skin with dyanamic hardware controls" ya que nos va a permitir un mejor acceso a todas las configuraciones que nos ofrece el AVD, ademas de los botones inferiores de control correspondientes a cualquier smartphone para ir al menu, atras o acceso a la multitarea.

Aunque el prototipo propuesto que acompaña a este trabajo de fin de grado esta basado en android-x86 y usando virtualbox,
BALBLLALBLALLABLLAXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Antes de lanzar por primera vez nuestro dispositivo virtual vamos a hacer un inciso importante y aclaratorio de como funciona el CLI (Command Line Interface, la línea de comandos) del emulator

1.2.- CLI del emulador.

Vamos a enfocar esta sección desde el punto de vista de cuckoodroid, como si fuesemos a ejercutarla en el entorno de ese framework. La justificación de esta decisión es sencilla y la vamos a entender fácilmente.

Cuckoodroid es un framework para analisis automatizado de apks que como se menciona en su sección correspondiente uno de sus grandes límites es la interacción con la máquina para que el proceso de análisis sea autómatico.

La justificación del uso en el prototipo de la version android-x86, es la aceleración que se consigue en la ejecución, pero resulta que a la hora de compilar un kernel válido has sido ardua tarea y además sin éxito.

Ahora lo que estamos intentando ofrecer en esta sección es una plataforma de análisis más exhaustivo a determinadas muestras de apk que podrían potencialmente maliciosas. Cuckoodroid nos ofrece una serie de herramientas que podríamos utilizar para preparar el dispositivo virtual, que están localizadas en la carpeta ~/cuckoo/utils/android_emulator_creator, entre apps y hooking y que se pueden colgar haciendo uso del script:

~/cuckoo/utils/android_emulator_creator/create_guest_avd.sh

Que ocurre, que para poder colgar con éxito esas herramientas debe lanzarse el dispositivo virtual a través del emulador de tal forma que el sistema permita hacer persistentes los cambios en el y que además tengamos los permisos necesarios para poder hacerlo. Pero aquí el destino nos tenía preparada otra gran trampa que necesitamos resolver.

Si revisamos los parámetros de lanzamiento del emulator que aparecen en cuckoodroid podemos ver que es esta línea:

emulator -avd aosx -qemu -nand -system,size=0x1f400000,file=<sdk_path>/system-images/android-16/default/armeabi-v7a/system.img&

la cual ACTUALMENTE NO funciona. Si buscamos los videos oficiales de cuckoodroid en el 3º de los 4 existen, se puede apreciar que la línea de comando difiere en el parámetro -writable-system, que lo que hace es montar el sistema en modo escritura: quedando más o menos así.

emulator -avd aosx -qemu -nand -writable-system -system,size=0x1f400000,file=<sdk_path>/system-images/android-16/default/armeabi-v7a/system.img&

la cual ACTUALMENTE de nuevo NO funciona. Este error se debe al cambio de versiones del SDK y en concreto en los parámetros que acepta el emulator, además del orden que deben llevar. Actualmente -nand no funciona y -qemu no esta puesto en el orden adecuado.

Antes de continuar me gustaría que se fijasen en estas dos imágenes y en las rutas.

[ficheros_avd]

[ficheros_reales_mv]

Como puede comprobarse cuando descargamos en el Android SDK Manager los ficheros de android 4.1.2 arm se guardan ya construidos en la carpeta 

~/android-sdk/system-images/android-16/default/armeabi-v7a 

Mientras que los ficheros de ejecución de la máquina virtual que vamos utilizar deben estar ubicados en la ruta oculta de la carpeta de usuario: 

~/.android/avd/aosx.avd

de la cual el prefijo aosx corresponde al nombre que le asignamos cuando creamos ese dispositivo o máquina virtual.

Esas rutas son importantes ya que lo que propone cuckoodroid es que copiemos el fichero de sistema system.img de la carpeta del AVD (primera imagen) en la carpeta aosx.avd (segunda imagen) y que además le asignemos el nombre de system-qemu.img quedando de la siguiente forma:

[ficheros_mv_qemu]

Bien si estudiasemos ahora los parámetros en la documentación del emulator de Android Source veriamos que los formatos de llamada no se corresponden y después de varias horas de cabezazos con ellos, la forma correcta de levantar nuestro dispositivo virtual desde la consola de comandos es:

emulator @aosx -writable-system -system ~/.android/avd/aosx.avd/system-qemu.img -qemu

Fijese que la ruta del fichero de sistema no es la del AVD, sino la de la máquina creada, con el fin de mantener intacto el fichero original cuando lo levantemos en modo escritura.

Puede consultar el resto de parámetros y opciones de emulator en:

https://developer.android.com/studio/run/emulator-commandline?hl=es-419

Podría haber obviado estás aclaraciones pero sin conocer estos detalles, no podríamos conseguir entender que para que cuckoodroid funcione con los nuevos SDK debemos modificar o corregir manualmente el fichero ~/cuckoo/modules/machinery/avd.py para que pueda lanzar correctamente y a nuestro gusto las maquinas virtuales, además de poder añadir el lanzamiento de la maquina virtual desde un snapshot en vez utilizar la estrategia lenta que realiza cuckoodroid para realizar análisis.

Dicha estrategia consiste en realizar una copia de la carpeta aosx.avd como aosx_1.avd y borrarla despues del analisis, y volver a hacer otra copia en el siguiente analisis y así sucesivamente, lo que hace que se demore cada analisis casi 3 minutos entre la operación de copia y el arranque en frío de la máquina virtual, lo cual al ser una emulación de arm conlleva una lentitud considerable para un análisis automático.


1.3.- Preparación del dispositivo virtual para análisis

Antes de seguir si al lanzar la maquina virtual se congela y no se recupera, pruebe lo siguiente:
- Actualizar java a la version 8 mínimo, esto hara que funcione correctamente el depurador y poder identificar errores.
- Si tiene tarjeta grafica NVIDIA:
sudo apt-get update
sudo apt-get purge nvidia-*
sudo apt-get install nvidia-current-updates
sudo reboot

Bien una vez que hemos aclarado como debemos arrancar correctamente nuestro dispositivo virtual es momento de agregar una serie de características o funcionalidades que nos vendrán muy bien en los futuros análisis.

Estas carácteristicas van a ser:

- Tener acceso root o superusurio (su) en el dispositivo virtual.
- Instalar el Xposed, ojo cuidado con las versiones que pueden brickear el arranque del dispostiivo virtual.
- Agregar los modulos de hooking EmulatorAntiDetect.apk y Droidmon.apk.

La forma de hacerlo cómodamente es lanzado el script de cuckoo situados en esa carpeta con:

cd ~/cuckoo/utils/android_emulator_creator/

./create_guest_avd.sh

Hay que lanzarlo desde esa carpeta ya que contiene una serie de rutas relativas a la carpeta actual.

Ademas hay que corregir una ruta añadiendo un punto (.) al path tal como se muestra en la imagen del script, si ha descargado el prototipo ese fragmento de código lo hemos corregido, pero si usa el del git oficial no lo han corregido todavia y provocara algunos errores en la comunicación con el agente.

[error_create_guest_avd.png]

Una vez colgadas todas las tools que nos ofrece cuckoodroid vamos a terminar de instalar los componentes y configurar las respuestas.

Aunque en la guía de cuckoodroid no indican ningún order en las operaciones siguientes, se RECOMIENDA no tocar de memento la configuracion de supersu y respetar este orden:

- Configurar la pantalla para que no se apague o retrasarlo 30 minutos
- Configurar la seguridad del bloqueo de pantalla a Ninguno.
- Activar en seguridad si no lo están los Orígenes de Fuentes de Terceros o Desconocidas.
- Iniciar la aplicacion GenerateContacts o crearlos a mano :)
- Abrir el XposedInstalled
  -activar los modulos Droidmon y AntiDegub
  -En framework pulsar en Intall/Update y permitir en el supersu
    -Esto nos pedirá reiniciar NO REINICIAR, pulsar en cancelar
    -Pulsar en SOFT REBOOT y aceptar.
- Cuando se reincie el dispositivo configurar supersu para permitir a todas la aplicaciones que lo pidan ejercutar su.

[imagenes]

2.- Compilando kernels de android
2.1.- Antes de empezar la compilación.

Se eligió la version de ubuntu 14.04 porque he podido comprobar que es la que mejor se integra para ello, a parte de ser la recomendada en Android Source, tal y como vimos anteriormente.

Pero compilar kernels para android no esta libre de errores y de horas desesperantes. Para versiones nuevas de android los requisitos son menos exigentes, es más, el mismo nivel de complejidad adquiere si en vez compilar kernels para AVD, queremos hacerlo para máquinas físicas. Aunque nuestro gran handicap que no hemos conseguido superar a sido compilar un kernel para la version android-x86-4.4-RC2.

En el momento de montar el prototipo de analisis y segun las indicaciones y la línea de trabajo marcada por el director del proyecto, debiamos utilizar maquinas virtuales basadas en x86 para conseguir la máxima aceleración que nos ofrece KVM-qemu. Las máquinas disponibles corresponden al proyecto de android-x86.org, de hecho cuckoodroid recomienda, casi obligatoriamente más que una recomendación, utilizar android-x86-4.4-RC2. En ese punto cuckoodroid usa volatility y claro necesitamos un profile para poder analizar los volcados. Por tanto para crear ese perfil debemos realizar básicamente los siguientes paso:

Compilar el kernel del dispostivo a analizar.
Compilar LiME para realizar los volcadosde memoria.
Compilar el profile para volatility.

2.2.- Cumpliendo requisitos.

Bien en el apartado preparando la maquina virtual con SDK anterior, hablamos de uan serie de dependencias que habia que cumplir y que ahora mismo recordamos que eran:

sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev libxml2-utils xsltproc unzip mesa-utils lib64stdc++6:i386

para ubuntu 14.04 64 bits, para otras versiones se puede consultar como digimos la seccion de inicializacion del entorno de construcción.

--El JDK

Ahora debemos tener en cuenta el jdk a utilizar, que permite seleccionar la libreria a utilizar y que se integra con el core: 

- Android 4.4.x o inferior es estrictamente necesario utilizar oracle-6-jdk. No nos sirve openjdk, esto lo hemos podido confirmar estudiando los Makefile y sus herederos en los que he intentado parchear los mensajes de error y efectivamente no compila si nos es con oracle-6-jdk. Ni tan siquiera la version 7 de este. Para la pruebas si lo desean en la carpeta tools de nuestro tfg he dejado una copia en formato .deb para que no tengan que lidiar por internet ni con las repos de ubuntu para encontrar este jdk, ya que la mayoría han cerrado su acceso a este jdk.

- Android 5 o 6 debe ser compilado con oracle-7-jdk u openjdk-7-jdk

- A partir de Android 7 se permite utilizar openjdk-8-jdk o superior.

--El SDK

Bien no vamos a entrar en detalles puesto que el sdk es necesario si vamos a crear compilaciones completas de android no solo el kernel, por tanto no vamos detenernos en este aspecto, ya que no vamos a necesitarlo para el kernel. 

Esta decisión puede ser muy apreciada por el lector interesado, ya que el tiempo que yo he dedicado a darme cuenta de este hecho, es el tiempo que dicho lector se va a ahorrar en calentamientos de cabeza buscando esta información, en que version necesita para compilar el kernel.

--El NDK

Tenemos aquí la pieza fundamental del puzzle. EL NDK de Android segun este, es un conjunto de herramientas que nos permite implementar partes de las aplicaciones en codigo nativo mediante lenguaje C o C++. Lo que permite la reutilización de bibliotecas que hayan sido escritas en ese lenguaje.

Existen diferentes versiones de NDK que han ido evolucionando con el trancurso de las versiones de Android. Para nuestro uso, que es el de la compilación del kernel, utilizaremos NDK para poder compilar para las distintas plataformas que necesitemos, arm, arm64, x86, x86-64,...

Recordemos que la mayoria de drivers, modulos o bibliotecas necesarias estan escritas en C o C++ por tanto el NDK es elemento que nos va a permitir "enlazar" ese código con la generación del binario necesario para cada plataforma mencionada que necesitemos usar.

El NDK no se trata de comenzar a elegir ndk al azar o ir probando uno a uno, sino que directamente hay que utilizar el que nos indica la documentacion que hay dentro del codigo fuente descargado para el propio kernel. 

Esto debe venir documentado por ejemplo en el codigo fuente de los Samsung. Sin embargo y no se porque motivo encontrar esta vez el adecuado cuando trabajamos con máquinas virtuales para AVD y kernel goldfish o ranchu no es tarea fácil y hay que lidiar un poco con la documentación e incluso tener que probar algunos.

En este punto debemos hablar de el TOOLCHAIN, que es la cadena de herramientas del NDK que se va a encargar de poder traducir la bibliotecas C/C++ en el codigo binario. Entra en juego el concepto de CROSS_COMPILE, es decir, la realización del cruce para la compilacion de las distintas arquitecturas y que es el toolchain quien se encarga de realizarlo.

Siempre vamos a necesitar de un toolchain que se encargue de realizar el cruce de la compilación para la arquitectura deseada. Ese nombre el CROSS_COMPILE vamos a necesitar configurarlo en cada compilación para que la maquinaria de compilación sepa que toolchain utilizar para la traducción. Esto es importante y es el detalle al que mas importancia y atención hay que prestarle.

Otros dos parámetros importantes a la hora de compilar van a ser las variables de entorno ARCH y SUBARCH, que junto con el CROSS_COMPILE, seran básicamente las que debamos definir antes de construir o compilar el kernel.

ARCH y SUBARCH van a definir la plataforma o arquitectura destino a la que vamos a compilar. en el caso que nos atañe va a ser arm, pero podria ser x86 para 32 bit o cualquier otro target de arquitectura de destino.

Lo normal es que antes de compilar o ejercutar el comando make exportemos esas 3 variables de entorno de la siguiente forma:

export ARCH=la_arquitectura
export SUBARCH=la_arquitectura
export CROSS_COMPILE=/ruta/toolchain/elegido-

por ejemplo para nuestro dispositivo virtual android 4.1.2 arm

export ARCH=arm
export SUBARCH=arm
export CROS_COMPILE=arm-eabi-

Fijese que el CROSS_COMPILE acaba con un guión, el cual es estrictamente necesario ya que si hechamos un vistazo a la carpeta de binarios podemos ver que todos utilizan el prefijo elejido y despues en el proceso de fabricación se le hirán añadiendo los distintos sufijos seleccionados según los vaya utilizando, es decir la cadena de herramientas de compilacion que realiza el make.

[toolchain1]

También podemos obviar la ruta completa o relativa al toolchain que vamos a utilizar siempre y cuando la hayamos inlcuido en el $PATH del sistema

Le recomiendo lea la siguiente sección para aclarar algunas cuestiones de las variables de entorno mencionadas.

--Más sobre el TOOLCHAIN

Es normal que utilicemos el NDK que contiene el toolchain que google nos ofrece, pero ojo, hay fabricantes que utilizan su propios toolchain y por tanto no nos sirva el de google, esto puede ser justificado por el uso de drivers privativos y en ese caso deberían ofredernos el NDK correspondiente que contenga el toolchain necesario para poder compilar el kernel, esto puede suceder con los procesadores Tegra. No es lo normal, pero es algo que deberiamos tener en cuenta por si acaso nos sucede.

Nosotros para evitar problemas nos hemos descargado todos los toolchain son 3.3gb aproximadamente en la carpeta toolchain de la carpeta de usuario con:

git clone https://android.googlesource.com/platform/prebuilt

Pued encontrarlos tambien en 

http://www.codesourcery.com/

aunque como podrá comprobar esa pagina a migrado a otro dominio y hay que registrarse, así sucede para dispositivos físicos como Samsung aunque nuevamente recordar que podemos usar los de google en principio.

Otra forma de obtener el toolchain correcto es descargar el codigo fuente de la compilación de la distribución y realizar un build a la version que querriamos compilar con el fin de visualizar con el comando env de linux cual es la ruta al CROSS_COMPILE necesario para esa compilación y por tanto para el kernel que utiliza. La información de descargas del codgio fuente se vera en la siguiente sección y se hablará de las herrameintas git y repo. La información de construccion build es conviente revisarla y aparece en la carpeta Documents de los fuentes descargados.

Otra formas mas de obtener los toolchains es buscarlos por inteenr como por ejemplo en:

https://dn.odroid.com/toolchains/

--Descargar fuentes.

Dependiendo de

GIT
Por todos, en mayor o menos medida, es conocida la herramienta git, un gestor de versiones para el desarrollo de proyectos.

Si el codigo fuente del kernel debemos conocer la dirección y realizar un clone, podemos recoger el proyecto git completo o bien seleccionar alguna version de este si la conocemos, con el comando 

git clone <direccion> <version> <carpetadestino> 

para poder visualizar las ramas tecleariamos

git branch -a

Donde podríamos ver las distintas ramas del proyecto


Mencionamos esto porque en ocasiones en la información del kernel linux de android aparece el commit adecuado que se utilizo, podemos saberlo con el comando:

adb shell cat /proc/version

donde aparecera la version del kernel linux y en ocasiones aparecera el commit adecuado, de seer asi podriamos hacer un

git checkout <numero_commit>

para seleccionar justamente ese commit y trabajar con esa version que quedará activada debido a ese checkout, ofreciendonos solamente los ficheros involucrados para la compilación de ese kernel.

REPO

Repo es una herramienta similar a git o mejor dicho una herramienta que podemos utilizar en combinacion con git. No es ni mejor ni peor, simplemente es otra herramienta, pero que difiere en su uso.

Dependiendo de la version de Ubuntu que usemos podemos encontrarlo en los repositorios con:

sudo apt-get install repo

Pero en nuestro ubuntu 14.04 no esta disponible y por tanto debemos ahcer los siguiente para utilizarlo:

mkdir ~/bin
PATH=~/bin:$PATH

curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo
chmod a+x ~/bin/repo

NOTA.- podemos agregarlo al $PATH para hacerlo persistente en el fichero ~/.bashrc de la carpeta de usuario.

Como vemos lo que ahcemos es crear una carpeta donde albergarlo y añadirla al $PATH, descargamos la herramienta y le damos permisos de ejecución.

Una vez instalada la herramienta podemos sincronizar los repositiorios necesarios que albergan la fuentes

















