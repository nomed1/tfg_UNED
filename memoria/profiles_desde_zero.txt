1.1.- Preparar la maquina con Android SDK

Se ha elegido el sdk r24.0.2-linux.tgz para poder conocer completamente el uso de las herramientas del sdk y avd y como se lanzan los modulos desde la consola de comandos, aunque si bien es cierto que el android studio es más amigable, trabajando desde la consola podemos conocer mas afondo las distintas partes del sdk, donde encontrarlas y para que sirven.

Lo primero que haremos será descomprimir en android SDK manager r24.0.2-linux.tgz y copiarlo como android-sdk en la carpeta de usuario.

Para comenzar trabajar con el sdk necesita algun jdk para ello, no nos importa de momento cual instalemos.

sudo apt-get install default-jdk

Ahora lanzamos el android SDK manager que esta en la carpeta con

~/android-sdk/tools/android

Seleccionamos tal como se muestra:

-Android SDK Tools
-Android SDK Platform-tools
-Android SDK Build-tools
-Android 4.1.2 (API 16)
  -SDK Platform
  -ARM EABI v7a System Image

Volvemos a lanzar:

~/android-sdk/tools/android

Y ahora seleccionamos las ultimas versiones que se nos ofrezcan que mostramos, esto depurará errores en la ejecución de la maquinas virtuales

-Android SDK Tools
-Android SDK Platform-tools
-Android SDK Build-tools

Antes de continuar vamos a agregar el SDK al PATH del sistema que podemos hacer persistente si lo agregamos en el fichero .bashrc para que no tengamos que agregarlo cada vez que abramos una terminal.

export PATH=$PATH:~/android-sdk/tools:~/android-sdk/build-tools/29.0.2/:~/android-sdk/platform-tools

Según aparece en la documentación de Android que se puede consultar aquí:

https://source.android.com/setup/build/initializing

para inicializar un entorno de construcción son necesarias las siguientes dependencias para ubuntu 14.04 64 bits.

sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev libxml2-utils xsltproc unzip mesa-utils lib64stdc++6:i386

he probado varias distribuiones de linux y realmente la que mejor se adecua y menos problemas da para crear máquinas virtuales con el avd manager y las posteriores operaciones de compilacion de kernel, LiME y la creación de profiles para volatility es la 14.04 tal y como se recomienda en el enlace anterior.

Si comprobamos la dependencias que recomiendan desde Android Source podemos comprobar que hemos añadido dos más, que las dos últimas de esa forma no tendremos problemas cuando estemos "construyendo".

Además algo que no nos mencionan en el Android Source y que nos ha ocasionado molestias a la hora de crear los ficheros correspondientes a las imágenes de sistema de las máquinas virtuales de avd, concretamente al generar el fichero que emularará la imagen de la /sdcard es por falta de permisos de ejecución en algunos de esos modulos, en este caso en el mksdcard. Si esto sucediera hay que darle permisos a la carpeta ~/android-sdk/tools podemos hacerlo con:

sudo chmod +x -R ~/android-sdk/tools

Una vez aclarado ese aspecto vamos a hacer uso el Android Virtual Device (AVD) Manager para crear nuestro dispositivo virtual o máquina virtual que usa cuckoodroid en el modo AVD, android 4.1.2 arm, y que la vamos a configurar de la forma que a continuación se expone. Notese que el tamaño de la tarjeta de memoria (sdcard) es de 800mb para que el volcado de emmoria de 512mb quepa sin problemas en la sdcard cuando lancemos LiME para obtener un volcado de memoria.

[imagen crear_mv_avd]

Como se puede apreciar en la imagen la configuración realizada es la que aparece en el wiki de cuckoodroid en el apartado de preparacion del invitado en modo Android emulator

https://cuckoo-droid.readthedocs.io/en/latest/installation/guest_android_avd/requirements/#create-android-virtual-device

y que tan sólo hemos cambiado he cambiado el tamaño de la sdcard a 800mb con la justificación aportada anteriormente.

Para parámetro SKIN vamos a seleccionar "Skin with dyanamic hardware controls" ya que nos va a permitir un mejor acceso a todas las configuraciones que nos ofrece el AVD, ademas de los botones inferiores de control correspondientes a cualquier smartphone para ir al menu, atras o acceso a la multitarea.

Aunque el prototipo propuesto que acompaña a este trabajo de fin de grado esta basado en android-x86 y usando virtualbox,
BALBLLALBLALLABLLAXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


Antes de lanzar por primera vez nuestro dispositivo virtual vamos a hacer un inciso importante y aclaratorio de como funciona el CLI (Command Line Interface, la línea de comandos) del emulator

1.2.- CLI del emulador.

Vamos a enfocar esta sección desde el punto de vista de cuckoodroid, como si fuesemos a ejercutarla en el entorno de ese framework. La justificación de esta decisión es sencilla y la vamos a entender fácilmente.

Cuckoodroid es un framework para analisis automatizado de apks que como se menciona en su sección correspondiente uno de sus grandes límites es la interacción con la máquina para que el proceso de análisis sea autómatico.

La justificación del uso en el prototipo de la version android-x86, es la aceleración que se consigue en la ejecución, pero resulta que a la hora de compilar un kernel válido has sido ardua tarea y además sin éxito.

Ahora lo que estamos intentando ofrecer en esta sección es una plataforma de análisis más exhaustivo a determinadas muestras de apk que podrían potencialmente maliciosas. Cuckoodroid nos ofrece una serie de herramientas que podríamos utilizar para preparar el dispositivo virtual, que están localizadas en la carpeta ~/cuckoo/utils/android_emulator_creator, entre apps y hooking y que se pueden colgar haciendo uso del script:

~/cuckoo/utils/android_emulator_creator/create_guest_avd.sh

Que ocurre, que para poder colgar con éxito esas herramientas debe lanzarse el dispositivo virtual a través del emulador de tal forma que el sistema permita hacer persistentes los cambios en el y que además tengamos los permisos necesarios para poder hacerlo. Pero aquí el destino nos tenía preparada otra gran trampa que necesitamos resolver.

Si revisamos los parámetros de lanzamiento del emulator que aparecen en cuckoodroid podemos ver que es esta línea:

emulator -avd aosx -qemu -nand -system,size=0x1f400000,file=<sdk_path>/system-images/android-16/default/armeabi-v7a/system.img&

la cual ACTUALMENTE NO funciona. Si buscamos los videos oficiales de cuckoodroid en el 3º de los 4 existen, se puede apreciar que la línea de comando difiere en el parámetro -writable-system, que lo que hace es montar el sistema en modo escritura: quedando más o menos así.

emulator -avd aosx -qemu -nand -writable-system -system,size=0x1f400000,file=<sdk_path>/system-images/android-16/default/armeabi-v7a/system.img&

la cual ACTUALMENTE de nuevo NO funciona. Este error se debe al cambio de versiones del SDK y en concreto en los parámetros que acepta el emulator, además del orden que deben llevar. Actualmente -nand no funciona y -qemu no esta puesto en el orden adecuado.

Antes de continuar me gustaría que se fijasen en estas dos imágenes y en las rutas.

[ficheros_avd]

[ficheros_reales_mv]

Como puede comprobarse cuando descargamos en el Android SDK Manager los ficheros de android 4.1.2 arm se guardan ya construidos en la carpeta 

~/android-sdk/system-images/android-16/default/armeabi-v7a 

Mientras que los ficheros de ejecución de la máquina virtual que vamos utilizar deben estar ubicados en la ruta oculta de la carpeta de usuario: 

~/.android/avd/aosx.avd

de la cual el prefijo aosx corresponde al nombre que le asignamos cuando creamos ese dispositivo o máquina virtual.

Esas rutas son importantes ya que lo que propone cuckoodroid es que copiemos el fichero de sistema system.img de la carpeta del AVD (primera imagen) en la carpeta aosx.avd (segunda imagen) y que además le asignemos el nombre de system-qemu.img quedando de la siguiente forma:

[ficheros_mv_qemu]

Bien si estudiasemos ahora los parámetros en la documentación del emulator de Android Source veriamos que los formatos de llamada no se corresponden y después de varias horas de cabezazos con ellos, la forma correcta de levantar nuestro dispositivo virtual desde la consola de comandos es:

emulator @aosx -writable-system -system ~/.android/avd/aosx.avd/system-qemu.img -qemu

Fijese que la ruta del fichero de sistema no es la del AVD, sino la de la máquina creada, con el fin de mantener intacto el fichero original cuando lo levantemos en modo escritura.

Puede consultar el resto de parámetros y opciones de emulator en:

https://developer.android.com/studio/run/emulator-commandline?hl=es-419

Podría haber obviado estás aclaraciones pero sin conocer estos detalles, no podríamos conseguir entender que para que cuckoodroid funcione con los nuevos SDK debemos modificar o corregir manualmente el fichero ~/cuckoo/modules/machinery/avd.py para que pueda lanzar correctamente y a nuestro gusto las maquinas virtuales, además de poder añadir el lanzamiento de la maquina virtual desde un snapshot en vez utilizar la estrategia lenta que realiza cuckoodroid para realizar análisis.

Dicha estrategia consiste en realizar una copia de la carpeta aosx.avd como aosx_1.avd y borrarla despues del analisis, y volver a hacer otra copia en el siguiente analisis y así sucesivamente, lo que hace que se demore cada analisis casi 3 minutos entre la operación de copia y el arranque en frío de la máquina virtual, lo cual al ser una emulación de arm conlleva una lentitud considerable para un análisis automático.


1.3.- Preparación del dispositivo 

Bien una vez que hemos aclarado como debemos arrancar correctamente nuestro dispositivo virtual es momento de agregar una serie de características o funcionalidades que nos vendrán muy bien en los futuros análisis.

Estas carácteristicas van a ser:

- Tener acceso root o superusurio (su) en el dispositivo virtual.
- Instalar el Xposed, ojo cuidado con las versiones que pueden brickear el arranque del dispostiivo virtual.
- Agregar los modulos de hooking EmulatorAntiDetect.apk y Droidmon.apk.

La forma de hacerlo cómodamente es lanzado el script de cuckoo situados en esa carpeta con:

cd ~/cuckoo/utils/android_emulator_creator/

./create_guest_avd.sh

Hay que lanzarlo desde esa carpeta ya que contiene una serie de rutas relativas a la carpeta actual.

Ademas hay que corregir una ruta añadiendo un punto (.) al path tal como se muestra en la imagen del script, si ha descargado el prototipo ese fragmento de código lo hemos corregido, pero si usa el del git oficial no lo han corregido todavia y provocara algunos errores en la comunicación con el agente.

[error_create_guest_avd.png]






